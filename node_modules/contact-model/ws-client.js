import Transmission from 'contact-model/transmission'
import WebSocket from 'ws'
import UserTransmission from 'contact-model/user'
import MessageTransmission from 'contact-model/message'
import sleep from 'sleep-anywhere'

class WebSocketClient {
  #ws
  id

  constructor (ws) {
    if (ws) this.setWs(ws)
  }

  async connect (url, options = {}) {
    const ws = await retry(
      async function connectAttempt () {
        return new Promise((resolve, reject) => {
          try {
            const ws = new WebSocket(url, options)
            ws.onopen = () => {
              resolve(ws)
            }
            ws.onerror = cause => {
              const err = new Error('wsClient.connect() failed: ' + cause.message, { cause })
              reject(err)
            }
          } catch (cause) {
            const err = new Error('wsClient.connect() failed: ' + cause.message, { cause })
            reject(err)
          }
        })
      },
      { retryAfter: [1000, 2000, 4000, 8000, 16000] }
    )
    this.onOpen()
    this.setWs(ws)
  }

  getWs () {
    return this.#ws
  }

  setWs (ws) {
    this.#ws = ws
    this.#ws.onclose = closeEvent => {
      const { code, reason, wasClean } = closeEvent
      this.onClose(code, reason, wasClean)
    }
    this.#ws.onmessage = async e => {
      const data = e.data
      const transmission = await Transmission.deserialise(data)
      // console.log(transmission)
      if (transmission.type === 'u') {
        this.onPresence(transmission, data)
      } else if (transmission.type === 'm') {
        this.onMessage(transmission, data)
      } else {
        const err = new Error('Unexpected transmission type')
        err.data = transmission
        throw err
      }
    }
  }

  async send (data, options) {
    if (this.#ws.readyState !== WebSocket.OPEN) {
      throw new Error('wsClient.send(): Invalid state')
    }
    if (!(typeof data === 'string' || Buffer.isBuffer(data))) {
      throw new Error('wsClient.send(): String or Buffer input only', { cause: data })
    }

    return new Promise((resolve, reject) => {
      this.#ws.send(data, options, (err) => {
        if (err) {
          reject(err)
        } else {
          resolve()
        }
      })
    })
  }

  async close () {
    this.#ws.close()
  }

  onOpen () {}

  onClose (code, reason, wasClean) {}

  onMessage (message) {}

  onPresence (user) {}

  /**
   * A userTransmission creation method.
   */
  async register (name, channels) {
    const user = new UserTransmission({
      from: { name, channels }
    })
    if (!user.isEmpty()) {
      await this.send(await user.serialise())
      return user
    } else {
      console.warn('Registering empty user', user)
    }
  }

  async message (from, to, body) {
    const message = new MessageTransmission({
      from,
      to,
      payload: body
    })
    if (!message.isEmpty()) {
      await this.send(await message.serialise())
      return message
    } else {
      console.warn('Sending empty message', message)
    }
  }

  static async connect (url, options) {
    const wsClient = new this()
    await wsClient.connect(url, options)
    return wsClient
  }
}

async function retry (operation, options = {}) {
  const retryAfter = options.retryAfter || []
  let complete = false
  let result
  while (!complete) {
    try {
      result = await operation()
      complete = true
    } catch (err) {
      const remainingRetries = retryAfter.length
      if (remainingRetries) {
        const waitPeriod = retryAfter.shift()
        await sleep(waitPeriod)
        complete = false
      } else {
        complete = true
        throw err
      }
    }
  }
  return result
}

export default WebSocketClient
